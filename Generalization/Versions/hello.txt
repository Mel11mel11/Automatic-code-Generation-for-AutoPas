#!/usr/bin/env python3
import os
import sys
import yaml
import sympy as sp
import textwrap
from replace import fix_exp
from sympy.printing.cxx import CXX11CodePrinter


def _validate_one(data: dict) -> dict: # for reading test yaml file
    name = data.get("name")
    expr = data.get("expression")
    out = data.get("output", {}) or {}
    classname = out.get("classname")
    filename = out.get("filename")
    options = data.get("options", {}) or {}
    params = data.get("parameters", {}) or {}

    if not all([name, expr, classname, filename]):
        raise ValueError("Missing required fields")

    return {
        "name": name,
        "expr_str": expr,
        "classname": classname,
        "filename": filename,
        "newton3_default": bool(options.get("newton3", True)),
        "eps_guard": float(options.get("avoid_r2_zero", 1e-24)),
        "parameters": params,
    }


def load_yaml_many(path: str) -> list[dict]:
    with open(path, "r") as f:
        docs = list(yaml.safe_load_all(f))
    items = []
    for doc in docs:
        if not doc:
            continue
        if "potentials" in doc:
            for it in doc["potentials"]:
                items.append(_validate_one(it))
        else:
            items.append(_validate_one(doc))
    return items



class FastPowPrinter(CXX11CodePrinter):
    def _print_Pow(self, expr):
        base, exp = expr.as_base_exp()
        if exp.is_Integer and 0 <= exp <= 20:
            return f"fast_pow({self._print(base)}, {int(exp)})"
        return f"std::pow({self._print(base)}, {self._print(exp)})"


_fastpow_printer = FastPowPrinter()


def ccode_fastpow(e):
    return _fastpow_printer.doprint(e)


def compute_dispersion_coeffs_sympy():
    C6, C8, C10 = sp.symbols("C6 C8 C10", real=True)
    C12 = C6 * (C10 / C8) ** 3
    C14 = C8 * (C12 / C10) ** 3
    C16 = C10 * (C14 / C12) ** 3
    return C12, C14, C16

def calculate_force(expr_str, param_names, add_dispersion):
    r = sp.Symbol("r", positive=True)
    sym_locals = {"r": r}

    for p in param_names:
        sym_locals[p] = sp.Symbol(p)

    if add_dispersion:
        C12, C14, C16 = compute_dispersion_coeffs_sympy()
        sym_locals["C12"] = C12
        sym_locals["C14"] = C14
        sym_locals["C16"] = C16

    U = sp.sympify(expr_str, locals=sym_locals)
    F = -sp.diff(U, r)
    F = sp.simplify(F)

    repl, exprs = sp.cse(F)
    F_final = exprs[0]

    temp_code = []
    for symb, rhs in repl:
        temp_code.append(f"const double {symb} = {fix_exp(ccode_fastpow(rhs))};")

    temps = "\n        ".join(temp_code)
    force_expr = fix_exp(ccode_fastpow(F_final))

    return temps, force_expr

def generate_krypton_fast(cfg):
    classname = cfg["classname"]
    eps = cfg["eps_guard"]
    newton3_default = cfg["newton3_default"]
    params = cfg["parameters"]

    # Constructor parameters (A, a1, a2, a_m1, b, C6, C8, C10)
    param_names = list(params.keys())
    ctor = ", ".join([f"double {p}" for p in param_names])
    ctor += ", bool newton3 = " + ("true" if newton3_default else "false")

    # Init list: _A(A), ..., _C10(C10), _C12(0), _C14(0), _C16(0), _newton3(newton3)
    init_list_elems = [f"_{p}({p})" for p in param_names]
    init_list_elems += ["_C12(0.0)", "_C14(0.0)", "_C16(0.0)", "_newton3(newton3)"]
    init_list = ", ".join(init_list_elems)

    # Aliases inside AoSFunctor
    alias_lines = [f"const double {p} = _{p};" for p in param_names]
    alias_lines += [
        "const double C12 = _C12;",
        "const double C14 = _C14;",
        "const double C16 = _C16;",
    ]
    alias_list = "\n        ".join(alias_lines)

    # Unrolled TT polynomials + r^-n
    tt_block = r"""
        const double br = b * r;
        const double exp_br = std::exp(-br);

        // powers of 1/r
        const double inv_r2 = 1.0 / (r * r);
        const double inv_r4  = inv_r2 * inv_r2;
        const double inv_r6  = inv_r4 * inv_r2;
        const double inv_r8  = inv_r6 * inv_r2;
        const double inv_r10 = inv_r8 * inv_r2;
        const double inv_r12 = inv_r10 * inv_r2;
        const double inv_r14 = inv_r12 * inv_r2;
        const double inv_r16 = inv_r14 * inv_r2;
        const double inv_r18 = inv_r16 * inv_r2;

        // Unrolled series for Sum_{k=0}^n (br^k / k!)
        double t1  = br;
        double t2  = t1 * br / 2.0;
        double t3  = t2 * br / 3.0;
        double t4  = t3 * br / 4.0;
        double t5  = t4 * br / 5.0;
        double t6  = t5 * br / 6.0;
        double t7  = t6 * br / 7.0;
        double t8  = t7 * br / 8.0;
        double t9  = t8 * br / 9.0;
        double t10 = t9 * br / 10.0;
        double t11 = t10 * br / 11.0;
        double t12 = t11 * br / 12.0;
        double t13 = t12 * br / 13.0;
        double t14 = t13 * br / 14.0;
        double t15 = t14 * br / 15.0;
        double t16 = t15 * br / 16.0;

        double S1  = 1.0 + t1;
        double S2  = S1  + t2;
        double S3  = S2  + t3;
        double S4  = S3  + t4;
        double S5  = S4  + t5;
        double S6  = S5  + t6;
        double S7  = S6  + t7;
        double S8  = S7  + t8;
        double S9  = S8  + t9;
        double S10 = S9  + t10;
        double S11 = S10 + t11;
        double S12 = S11 + t12;
        double S13 = S12 + t13;
        double S14 = S13 + t14;
        double S15 = S14 + t15;
        double S16 = S15 + t16;

        const double D6  = 1.0 - exp_br * S6;
        const double D8  = 1.0 - exp_br * S8;
        const double D10 = 1.0 - exp_br * S10;
        const double D12 = 1.0 - exp_br * S12;
        const double D14 = 1.0 - exp_br * S14;
        const double D16 = 1.0 - exp_br * S16;
    """

    # Force expression: repulsive + damped dispersion part
    force = r"""
        const double exp_main = std::exp(a1*r + a2*r*r + a_m1/r + b*r);

        double F = A * exp_main * (a1 + 2.0*a2*r - a_m1/(r*r) + b);

        F += C6  * (-6.0  * inv_r8 ) * D6;
        F += C8  * (-8.0  * inv_r10) * D8;
        F += C10 * (-10.0 * inv_r12) * D10;
        F += C12 * (-12.0 * inv_r14) * D12;
        F += C14 * (-14.0 * inv_r16) * D14;
        F += C16 * (-16.0 * inv_r18) * D16;
    """

    # Members: parameters + C12,C14,C16 + newton3
    member_list = [f"double _{p};" for p in param_names]
    member_list += ["double _C12;", "double _C14;", "double _C16;", "bool _newton3;"]
    members = "\n    ".join(member_list)

    cpp = f"""
#pragma once
#include "../Functors/Functor.h"
#include "../Particle.h"
#include <cmath>
#include <array>

template<class Particle_T>
class {classname} : public Functor<Particle_T> {{
public:
    explicit {classname}({ctor})
        : {init_list}
    {{
        // Precompute higher dispersion coefficients once per functor
        _C12 = _C6 * std::pow(_C10 / _C8, 3.0);
        _C14 = _C8 * std::pow(_C12 / _C10, 3.0);
        _C16 = _C10 * std::pow(_C14 / _C12, 3.0);
    }}

    void AoSFunctor(Particle_T& p1, Particle_T& p2) override {{
        const auto& ra = p1.getR();
        const auto& rb = p2.getR();
        double dx = ra[0] - rb[0];
        double dy = ra[1] - rb[1];
        double dz = ra[2] - rb[2];

        constexpr double EPS = {eps};
        double r2 = dx*dx + dy*dy + dz*dz;
        if(r2 < EPS) r2 = EPS;

        const double r = std::sqrt(r2);
        const double inv_r = 1.0 / r;

        {alias_list}

        {tt_block}
        {force}

        const double Fmag = F;

        const double fx = Fmag * dx * inv_r;
        const double fy = Fmag * dy * inv_r;
        const double fz = Fmag * dz * inv_r;

        std::array<double,3> Fv{{fx, fy, fz}};
        p1.addF(Fv);
        if(_newton3) p2.subF(Fv);
    }}

private:
    {members}
}};
"""
    return textwrap.dedent(cpp)


def emit_header(
    classname,
    temps_code,
    force_expr,
    newton3_default,
    eps_guard,
    param_names,
    add_dispersion,  # şu an kullanılmıyor (Krypton emit_header'a girmiyor)
):
    # 1) ctor parameter list
    if param_names:
        ctor_param_sig = ", ".join(f"double {p}" for p in param_names) + ", "
    else:
        ctor_param_sig = ""
    ctor_param_sig += f"bool newton3 = {'true' if newton3_default else 'false'}"

    # 2) init list
    init_list_elems = [f"_{p}({p})" for p in param_names]
    # Mie için ek C runtime member'ı
    if classname.lower().startswith("mie"):
        init_list_elems.append("_C(0.0)")
    init_list_elems.append("_newton3(newton3)")
    init_list = ", ".join(init_list_elems)

    # 3) aliases
    alias_list = [f"const double {p} = _{p};" for p in param_names]
    if classname.lower().startswith("mie"):
        alias_list.append("const double C = _C;")
    local_aliases = "\n        ".join(alias_list)

    # 4) members
    member_decls = [f"double _{p};" for p in param_names]
    if classname.lower().startswith("mie"):
        member_decls.append("double _C;")
    member_decls.append("bool _newton3;")
    member_decls_str = "\n    ".join(member_decls)

    # 5) Mie runtime C hesaplama
    if classname.lower().startswith("mie"):
        mie_runtime = """
        _C = (_n / (_n - _m)) * std::pow(_n / _m, _m / (_n - _m));
        """
    else:
        mie_runtime = ""

    body = f"""
#pragma once
#include "../Functors/Functor.h"
#include "../Particle.h"
#include <cmath>
#include <array>
#include "FastPow.hpp"

template <class Particle_T>
class {classname} : public Functor<Particle_T> {{
public:
    explicit {classname}({ctor_param_sig})
        : {init_list}
    {{
        {mie_runtime}
    }}

    void AoSFunctor(Particle_T& p1, Particle_T& p2) override {{
        const auto& ra = p1.getR();
        const auto& rb = p2.getR();
        double dx = ra[0] - rb[0];
        double dy = ra[1] - rb[1];
        double dz = ra[2] - rb[2];

        constexpr double EPS = {eps_guard};
        double r2 = dx*dx + dy*dy + dz*dz;
        if (r2 < EPS) r2 = EPS;

        const double r = std::sqrt(r2);
        const double inv_r = 1.0 / r;

        // Parameter aliases
        {local_aliases}

        const double p1m = p1.getMass();
        const double p2m = p2.getMass();

        // CSE temporaries
        {temps_code}

        // Final force magnitude
        const double Fmag = {force_expr};

        const double fx = Fmag * dx * inv_r;
        const double fy = Fmag * dy * inv_r;
        const double fz = Fmag * dz * inv_r;

        std::array<double,3> F{{fx, fy, fz}};
        p1.addF(F);
        if (_newton3) {{
            p2.subF(F);
        }}
    }}

    bool allowsNewton3() const {{ return true; }}
    bool usesNewton3() const {{ return _newton3; }}

private:
    {member_decls_str}
}};
"""
    return textwrap.dedent(body)


def main():
    if len(sys.argv) < 3:
        print("Usage: python3 main.py <spec.yaml> <out_dir>")
        return

    yaml_path = sys.argv[1]
    out_dir = sys.argv[2]
    os.makedirs(out_dir, exist_ok=True)

    cfgs = load_yaml_many(yaml_path)

    for cfg in cfgs:
        classname = cfg["classname"]
        params = cfg["parameters"]
        param_names = list(params.keys())

    
        if classname.lower().startswith("krypton"):
            cpp = generate_krypton_fast(cfg)
            out_path = os.path.join(out_dir, cfg["filename"])
            with open(out_path, "w") as f:
                f.write(cpp)
            print("[FAST] Krypton generated:", cfg["filename"])
            continue

 
        add_dispersion = all(k in param_names for k in ["C6", "C8", "C10"])
        temps, force = calculate_force(cfg["expr_str"], param_names, add_dispersion)

        cpp = emit_header(
            classname,
            temps,
            force,
            cfg["newton3_default"],
            cfg["eps_guard"],
            param_names,
            add_dispersion,
        )

        out_path = os.path.join(out_dir, cfg["filename"])
        with open(out_path, "w") as f:
            f.write(cpp)

        print("[OK] Generated:", cfg["filename"])


if __name__ == "__main__":
    main()

#!/usr/bin/env python3
import os
import sys
import yaml
import sympy as sp
import textwrap
from replace import fix_exp
from sympy.printing.cxx import CXX11CodePrinter


# ============================================================
# VALIDATION
# ============================================================
def _validate_one(data: dict) -> dict:
    name = data.get("name")
    expr = data.get("expression")
    out = data.get("output", {}) or {}
    classname = out.get("classname")
    filename = out.get("filename")
    options = data.get("options", {}) or {}
    params = data.get("parameters", {}) or {}

    if not all([name, expr, classname, filename]):
        raise ValueError("Missing required fields")

    return {
        "name": name,
        "expr_str": expr,
        "classname": classname,
        "filename": filename,
        "newton3_default": bool(options.get("newton3", True)),
        "eps_guard": float(options.get("avoid_r2_zero", 1e-24)),
        "parameters": params,
    }


# ============================================================
# YAML loader
# ============================================================
def load_yaml_many(path: str) -> list[dict]:
    with open(path, "r") as f:
        docs = list(yaml.safe_load_all(f))
    items = []
    for doc in docs:
        if not doc:
            continue
        if "potentials" in doc:
            for it in doc["potentials"]:
                items.append(_validate_one(it))
        else:
            items.append(_validate_one(doc))
    return items


# ============================================================
# FAST POW PRINTER
# ============================================================
class FastPowPrinter(CXX11CodePrinter):
    def _print_Pow(self, expr):
        base, exp = expr.as_base_exp()
        if exp.is_Integer and 0 <= exp <= 20:
            return f"fast_pow({self._print(base)}, {int(exp)})"
        return f"std::pow({self._print(base)}, {self._print(exp)})"

_fastpow_printer = FastPowPrinter()

def ccode_fastpow(e):
    return _fastpow_printer.doprint(e)


# ============================================================
# LEVEL-2 OPTIMIZER  
# (CSE + 1/r^n -> inv_r^n + exp factoring)
# ============================================================
def optimize_level2(expr):

    expr = sp.simplify(expr)

    r = sp.Symbol("r", positive=True)
    inv_r = sp.Symbol("inv_r", positive=True)

    # ----- 1/r^n → inv_r^n -----
    def conv(node):
        if isinstance(node, sp.Pow):
            base, exp = node.as_base_exp()
            if base == r and exp.is_integer and exp < 0:
                return inv_r ** int(-exp)
        return node

    expr = expr.replace(lambda x: isinstance(x, sp.Pow), conv)
    expr = sp.simplify(expr)

    # ----- CSE -----
    repl, exprs = sp.cse(expr, optimizations="basic")
    reduced = exprs[0]

    # ----- exp(...) factoring -----
    exp_terms = [t for t in reduced.atoms(sp.exp)]
    exp_map = {}
    for i, t in enumerate(exp_terms):
        sym = sp.Symbol(f"exp_tmp_{i}")
        exp_map[t] = sym

    if exp_map:
        reduced = reduced.xreplace(exp_map)

    return repl, reduced, exp_map


# ============================================================
# DISPERSION (SymPy) – generic path için opsiyonel
# ============================================================
def compute_dispersion_coeffs_sympy():
    C6, C8, C10 = sp.symbols("C6 C8 C10")
    C12 = C6 * (C10 / C8)**3
    C14 = C8 * (C12 / C10)**3
    C16 = C10 * (C14 / C12)**3
    return C12, C14, C16


# ============================================================
# GENERIC FORCE CALC (Level-2 optimized)
# ============================================================
def calculate_force(expr_str, param_names, add_dispersion):
    r = sp.Symbol("r", positive=True)
    sym_locals = {"r": r}

    # parameters
    for p in param_names:
        sym_locals[p] = sp.Symbol(p)

    # p1m / p2m
    sym_locals["p1m"] = sp.Symbol("p1m")
    sym_locals["p2m"] = sp.Symbol("p2m")

    # C12-C16 if required
    if add_dispersion:
        C12, C14, C16 = compute_dispersion_coeffs_sympy()
        sym_locals["C12"] = C12
        sym_locals["C14"] = C14
        sym_locals["C16"] = C16

    # Build U, compute F = -dU/dr
    U = sp.sympify(expr_str, locals=sym_locals)
    F = -sp.diff(U, r)

    # Apply Level-2 optimizer
    repl, reduced, exp_map = optimize_level2(F)

    # ---- Generate C++ temps ----
    temp_lines = []
    for symb, rhs in repl:
        temp_lines.append(f"const double {symb} = {fix_exp(ccode_fastpow(rhs))};")

    # exp tmp’s
    exp_lines = []
    for t, sym in exp_map.items():
        arg = t.args[0]
        exp_lines.append(
            f"const double {sym} = std::exp({fix_exp(ccode_fastpow(arg))});"
        )

    temps_code = "\n        ".join(temp_lines + exp_lines) if (temp_lines or exp_lines) else ""

    force_expr = fix_exp(ccode_fastpow(reduced))

    return temps_code, force_expr


# ============================================================
# EMIT_HEADER – single universal path (ALL potentials)
# ============================================================
def emit_header(
    classname,
    temps_code,
    force_expr,
    newton3_default,
    eps_guard,
    param_names,
    add_dispersion,
):
    # ctor
    if param_names:
        ctor_param_sig = ", ".join(f"double {p}" for p in param_names) + ", "
    else:
        ctor_param_sig = ""
    ctor_param_sig += f"bool newton3 = {'true' if newton3_default else 'false'}"

    # init list
    init_list_elems = [f"_{p}({p})" for p in param_names]
    if add_dispersion:
        init_list_elems += ["_C12(0.0)", "_C14(0.0)", "_C16(0.0)"]
    if classname.lower().startswith("mie"):
        init_list_elems.append("_C(0.0)")
    init_list_elems.append("_newton3(newton3)")
    init_list = ", ".join(init_list_elems)

    # aliases
    alias_list = [f"const double {p} = _{p};" for p in param_names]
    if add_dispersion:
        alias_list += ["const double C12 = _C12;", "const double C14 = _C14;", "const double C16 = _C16;"]
    if classname.lower().startswith("mie"):
        alias_list.append("const double C = _C;")
    local_aliases = "\n        ".join(alias_list)

    # member declarations
    member_decls = [f"double _{p};" for p in param_names]
    if add_dispersion:
        member_decls += ["double _C12;", "double _C14;", "double _C16;"]
    if classname.lower().startswith("mie"):
        member_decls.append("double _C;")
    member_decls.append("bool _newton3;")
    member_decls_str = "\n    ".join(member_decls)

    # Mie runtime C compute
    if classname.lower().startswith("mie"):
        mie_runtime = """
        _C = (_n / (_n - _m)) * std::pow(_n / _m, _m / (_n - _m));
        """
    else:
        mie_runtime = ""

    # Dispersion C12-C16 runtime compute
    if add_dispersion:
        disp_runtime = """
        _C12 = _C6 * std::pow(_C10 / _C8, 3.0);
        _C14 = _C8 * std::pow(_C12 / _C10, 3.0);
        _C16 = _C10 * std::pow(_C14 / _C12, 3.0);
        """
    else:
        disp_runtime = ""

    body = f"""
#pragma once
#include "../Functors/Functor.h"
#include "../Particle.h"
#include <cmath>
#include <array>
#include "FastPow.hpp"

template <class Particle_T>
class {classname} : public Functor<Particle_T> {{
public:
    explicit {classname}({ctor_param_sig})
        : {init_list}
    {{
        {mie_runtime}
        {disp_runtime}
    }}

    void AoSFunctor(Particle_T& p1, Particle_T& p2) override {{
        const auto& ra = p1.getR();
        const auto& rb = p2.getR();
        double dx = ra[0] - rb[0];
        double dy = ra[1] - rb[1];
        double dz = ra[2] - rb[2];

        constexpr double EPS = {eps_guard};
        double r2 = dx*dx + dy*dy + dz*dz;
        if (r2 < EPS) r2 = EPS;

        const double r = std::sqrt(r2);
        const double inv_r = 1.0 / r;

        // Parameter aliases
        {local_aliases}

        const double p1m = p1.getMass();
        const double p2m = p2.getMass();

{("        " + temps_code) if temps_code else ""}

        const double Fmag = {force_expr};

        const double fx = Fmag * dx * inv_r;
        const double fy = Fmag * dy * inv_r;
        const double fz = Fmag * dz * inv_r;

        std::array<double,3> F{{fx, fy, fz}};
        p1.addF(F);
        if (_newton3) p2.subF(F);
    }}

    bool allowsNewton3() const {{ return true; }}
    bool usesNewton3() const {{ return _newton3; }}

private:
    {member_decls_str}
}};
"""
    return textwrap.dedent(body)


# ============================================================
# MAIN
# ============================================================
def main():
    if len(sys.argv) < 3:
        print("Usage: python3 main.py <spec.yaml> <out_dir>")
        return

    yaml_path = sys.argv[1]
    out_dir = sys.argv[2]
    os.makedirs(out_dir, exist_ok=True)

    cfgs = load_yaml_many(yaml_path)

    for cfg in cfgs:
        classname = cfg["classname"]
        params = cfg["parameters"]
        param_names = list(params.keys())

        # dispersion?
        add_dispersion = all(k in param_names for k in ["C6", "C8", "C10"])

        # universal level-2 path
        temps, force = calculate_force(cfg["expr_str"], param_names, add_dispersion)

        cpp = emit_header(
            classname,
            temps,
            force,
            cfg["newton3_default"],
            cfg["eps_guard"],
            param_names,
            add_dispersion,
        )

        out_path = os.path.join(out_dir, cfg["filename"])
        with open(out_path, "w") as f:
            f.write(cpp)

        print("[LEVEL-2] Generated:", cfg["filename"])


if __name__ == "__main__":
    main()

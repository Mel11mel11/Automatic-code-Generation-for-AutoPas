# mie_codegen.py â€” best version
import sympy as sp
from sympy.printing.c import ccode

# Symbols (positive=True ipucu verir; sayÄ±sal olmayan semboller olduklarÄ± iÃ§in Python if'leriyle kÄ±yaslanmazlar)
n, m, r, eps, sig = sp.symbols('n m r eps sig', positive=True)

# ---- Mie constants & expressions ----
# Normalization: C(n,m) = n/(n-m) * (n/m)^(m/(n-m))   (requires n > m)
C = (n/(n - m)) * (n/m)**(m/(n - m))

sr = sig / r
V  = C * eps * (sr**n - sr**m)        # Potential
print("\033[1;36mPotential V(r) = %s\033[0m\n" % V)
F  = -sp.diff(V, r)                   # Force = -dV/dr
F  = sp.simplify(F)
print(f"\033[1;94mSimplified Force F(r) = {F}\033[0m\n")

# Minimum (well) position: r_min = sigma * (n/m)^(1/(n - m))   (requires n > m)
rmin_expr = sig * (n/m)**(1/(n - m))

# ---- CSE (Common Subexpression Elimination) to reduce pow() calls ----
repl, reduced = sp.cse([F], optimizations='basic')
F_reduced = reduced[0]

# Code pieces
repl_code = [f"const double {ccode(sym)} = {ccode(expr)};" for (sym, expr) in repl]
F_code    = ccode(F_reduced)
C_code    = ccode(C)
rmin_code = ccode(rmin_expr)

# header (.hpp) 
# ... (Ã¼st kÄ±sÄ±m aynÄ±: semboller, C, V, F, CSE, F_code/C_code/rmin_code vs.)

# ---------- HEADER (.hpp) â€” no f-string, guards fully inside ----------
hpp = """#pragma once
#ifndef GENERATED_MIE_HPP
#define GENERATED_MIE_HPP

#include <stdexcept>

/*
  Auto-generated by mie_codegen.py
  SymPy CSE is applied to reduce repeated power terms like (sigma/r)^n and (sigma/r)^m.
  NOTE: A proper Mie well requires n > m; validated at runtime in force_safe().
*/

namespace mie {

// Helpers
double C(double n, double m);
double rmin(double sig, double n, double m);

// Implementations
double force_fast(double r, double eps, double sig, double n, double m);
double force_safe(double r, double eps, double sig, double n, double m);

// Runtime switch (flagâ€™siz kullanÄ±m)
inline double computeForce(double r, double eps, double sig, double n, double m, bool safeVersion = false) {
    return safeVersion ? force_safe(r, eps, sig, n, m)
                       : force_fast(r, eps, sig, n, m);
}
} // namespace mie
#endif // GENERATED_MIE_HPP
"""
with open("../generated_files/generated_mie.hpp", "w") as f:
    f.write(hpp)
# ---------- IMPLEMENTATION (.cpp) ----------
cpp = f"""// generated_mie.cpp
#include <cmath>
#include <stdexcept>
#include "generated_mie.hpp"
namespace mie {{
using std::pow; // ccode 'pow' Ã¼retir; std:: ile eÅŸleÅŸtir
static void validate(double r, double eps, double sig, double n, double m) {{
    if (!(r > 0.0))            throw std::invalid_argument("Mie: r must be > 0");
    if (!(eps > 0.0))          throw std::invalid_argument("Mie: epsilon must be > 0");
    if (!(sig > 0.0))          throw std::invalid_argument("Mie: sigma must be > 0");
    if (!(n > 0.0 && m > 0.0)) throw std::invalid_argument("Mie: n,m must be > 0");
    if (!(n > m))              throw std::invalid_argument("Mie: require n > m for a proper well");
}}
double C(double n, double m) {{
    // C(n,m) = {C_code}
    return {C_code};
}}
double rmin(double sig, double n, double m) {{
    // r_min = {rmin_code}
    return {rmin_code};
}}
// Fast: no validation (same softening as safe)
double force_fast(double r, double eps, double sig, double n, double m) {{
    if (r < 1e-12) r = 1e-12;
{"\n".join("    " + line for (line) in repl_code)}
    return {F_code};
}}
// Safe: validates then same formula
double force_safe(double r, double eps, double sig, double n, double m) {{
    validate(r, eps, sig, n, m);
    if (r < 1e-12) r = 1e-12;
{"\n".join("    " + line for (line) in repl_code)}
    return {F_code};
}}
}} // namespace mie
"""
with open("../generated_files/generated_mie.cpp", "w") as f:
    f.write(cpp)
print("\\033[1;33mC++ code generated successfully ðŸŸ¢ "
      "Look into generated_mie.cpp and .hpp files!\\033[0m\\n")
